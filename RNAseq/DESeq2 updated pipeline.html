---
title: "BR3 pipeline DeSeq2"
format: html
---

```{r}
suppressPackageStartupMessages({
  library(DESeq2)
  library(ggplot2)
  library(ggrepel)
  library(pheatmap)
  library(matrixStats)
  library(limma)
  library(goseq)
})

# Output dirs
out_base <- file.path("RNAseq_project", "BR123_ATC")
dir.create(out_base, recursive = TRUE, showWarnings = FALSE)

out_tables <- file.path(out_base, "tables")
out_plots  <- file.path(out_base, "plots")
out_goseq  <- file.path(out_base, "goseq")
dir.create(out_tables, recursive = TRUE, showWarnings = FALSE)
dir.create(out_plots,  recursive = TRUE, showWarnings = FALSE)
dir.create(out_goseq,  recursive = TRUE, showWarnings = FALSE)

```

## Saving Counts from Counts Matrix

To save a table of specific counts from your target gene within the counts matrix, rather than sifting through all the genes and samples:

```{r}

CountsMatrix1 <- read.csv("~/Desktop/LIDo/PhD/RNAseq_project/BR3/CountsMatrix_real.csv")
View(CountsMatrix1)
library(DESeq2)
counts <- CountsMatrix1   # change if needed

# Put gene IDs into rownames if needed
if (!is.null(colnames(counts)) && colnames(counts)[1] %in% c("Gene","gene","gene_id","X")) {
     rownames(counts) <- make.unique(as.character(counts[[1]]))
     counts[[1]] <- NULL
}
counts <- as.matrix(counts)
storage.mode(counts) <- "numeric"
# Extract MSMEG_3117 counts
stopifnot("MSMEG_3117" %in% rownames(counts))
msmeg3117_counts <- counts["MSMEG_3117", ]
# Build tidy table
msmeg3117_table <- data.frame(
     gene_id   = "MSMEG_3117",
     sample    = colnames(counts),
     counts    = as.numeric(msmeg3117_counts),
     row.names = NULL,
     check.names = FALSE)

msmeg3117_table

write.csv(
     msmeg3117_table,
     "MSMEG_3117_raw_counts_by_sample.csv",
     row.names = FALSE
)
```

## Load Counts Matrix (from featureCounts data) - (optional) preliminary run in DESeq2

The **counts matrix** must be created from each individual featureCounts file in Galaxy, including the gene id names as the first column/title for each row. This can be done in many ways - I did this manually in excel and exported the table as a .csv and uploaded to R studio (i.e., CountsMatrix1 for all BRs). This code also hinges in the presence of *coldata*, a data table containing the sample names and conditions/replicate specifications, e.g.,:

|                      | sample           | condition       | replicate |
|:---------------------|:-----------------|:----------------|:----------|
| **BR3_sgRNAneg_ATc** | BR3_sgRNAneg_ATc | sgRNAneg_ATcpos | BR3       |
| **BR3_sgRNApos**     | BR3_sgRNApos     | sgRNApos_ATcneg | BR3       |
| **BR3_sgRNApos_ATc** | BR3_sgRNApos_ATc | sgRNApos_ATcpos | BR3       |
| **BR1_sgRNAneg_ATc** | BR1_sgRNAneg_ATc | sgRNAneg_ATcpos | BR1       |
| **BR1_sgRNApos**     | BR1_sgRNApos     | sgRNApos_ATcneg | BR1       |
| **BR1_sgRNApos_ATc** | BR1_sgRNApos_ATc | sgRNApos_ATcpos | BR1       |
| **BR2_sgRNAneg_ATc** | BR2_sgRNAneg_ATc | sgRNAneg_ATcpos | BR2       |
| **BR2_sgRNApos**     | BR2_sgRNApos     | sgRNApos_ATcneg | BR2       |
| **BR2_sgRNApos_ATc** | BR2_sgRNApos_ATc | sgRNApos_ATcpos | BR2       |

```{r}
# Build coldata directly from count matrix
samples <- colnames(count_mat)
samps_l <- tolower(samples)
replicate <- factor(sub("^((br)[0-9]+).*", "\\\\1", samps_l),
                     levels = c("br1","br2","br3"))

has_atc <- grepl("atc", samps_l)
has_pos <- grepl("sgrnapos|sgrna\\\\+|sgrna\\\\.a", samps_l)
has_neg <- grepl("sgrnaneg|sgrna\\\\-|sgrna\\\\.ve", samps_l)

condition <- ifelse(has_neg & has_atc, "sgRNAneg_ATc",
              ifelse(has_pos & !has_atc, "sgRNApos",
              ifelse(has_pos & has_atc, "sgRNApos_ATc", NA_character_)))
 

condition <- factor(condition, levels = c("sgRNAneg_ATc","sgRNApos","sgRNApos_ATc"))

coldata <- data.frame(
   sample = samples,
   condition = condition,
   replicate = replicate,
   row.names = samples
)

# Format the counts matrix - put gene IDs into rownames, drop the Gene column, keep only numeric sample columns
count_df <- CountsMatrix1
rownames(count_df) <- count_df$Gene
count_df$Gene <- NULL

# Convert to matrix + integer counts
count_mat <- as.matrix(count_df)
storage.mode(count_mat) <- "numeric"   # guards against characters
count_mat <- round(count_mat)

# 3) Make sure columns match coldata rows (same samples, same order)
count_mat <- count_mat[, rownames(coldata), drop = FALSE]


# 4) Subset to ATc+-only two-level comparison

# As I am only comparing sgRNAneg and sgRNApos +ATC, I only need to run these in the DESeq2 model, as sgRNApos' counts may affect the estimations of the model, even though it is not being counted in the output comparison, the model will still technically be three-levels instead of the two-level we want. Though both are valid methods, the three-level modelwill affect how many genes pass the FDR/padj and may skew top DEGs.
  
# Keep ATc+ only (6 samples)
keep_cols <- colnames(count_mat)[
  grepl("^BR[123]_sgRNAneg_ATc$", colnames(count_mat)) |
  grepl("^BR[123]_sgRNApos_ATc$", colnames(count_mat))
]
stopifnot(length(keep_cols) == 6)

count_mat_atc <- count_mat[, keep_cols, drop = FALSE]
count_mat_atc <- count_mat_atc[rowSums(count_mat_atc) > 0, , drop = FALSE]

# Build coldata from sample names
samps_l <- tolower(keep_cols)

replicate <- factor(sub("^(br[123]).*", "\\1", samps_l), levels = c("br1","br2","br3"))
condition <- ifelse(grepl("sgrnaneg_atc$", samps_l), "sgRNAneg_ATc", "sgRNApos_ATc")
condition <- factor(condition, levels = c("sgRNAneg_ATc", "sgRNApos_ATc"))

coldata <- data.frame(replicate = replicate, condition = condition, row.names = keep_cols)
print(table(coldata$replicate, coldata$condition))
  
# 5) Build DESeq2 object (pre-batch testing)
dds <- DESeqDataSetFromMatrix(
     countData = count_mat_atc,
     colData   = coldata,
     design    = ~ condition )

dds <- DESeq(dds)

res <- results(
     dds,
     contrast = c("condition", "sgRNApos_ATc", "sgRNAneg_ATc"))
res <- lfcShrink(dds,
                     coef = "condition_sgRNApos_ATc_vs_sgRNAneg_ATc",
                     res = res,
                     type = "apeglm")
summary(res)
```

## Batch effect testing with limma/PCA plots

Before using limma to look at batch, data has to be normalised.

We can run look at batch with PCA before correcting.

rlog counts can be used for data with fewer samples - this is a normalisation designed for plots and stabilises variance across high and low counts, so you can observe principle component differences (I.e., PCs).

With limma for batch correction, we can feed the DESeq2 rlog (or VST if working with more samples) counts and account for batch with limma::removeBatchffect. This tool tool is used to model the PCA with batch effect accounted for and taken away. This can help decipher whether batch is affecting your data.

You can also use limma voom - a tool converts counts to logCPM, which models mean-variance relationship, and is better designed for limma testing to generate a PCA. You can run this as a means of visualisation, and also continue with DESeq2 as the main differential expression model, but this can get confusing. So either run DESeq2 or limmavoom for batch testing and differential expression.

It is important to note that these counts do not affect differential expression testing, as these are separate batches of code to DESeq2 and will not be fed into DESeq2. limma batch testing is for visualisation only, and batch can be fed into the DESeq2 model later if it is observed within the PCA's when limma is used. DO NOT FEED rLOG/logCPM COUNTS INTO DESEQ2!

```{r}
suppressPackageStartupMessages({
  library(DESeq2)
  library(limma)
  library(ggplot2)
  library(ggrepel)
})

# output directory
outdir <- file.path("RNAseq_project", "BR3")
if (!dir.exists(outdir)) dir.create(outdir, recursive = TRUE)

# -------------------------
# 1) Input raw counts
# -------------------------
counts <- CountsMatrix1

# Put gene IDs into rownames if first column is Gene
if (!is.null(colnames(counts)) && colnames(counts)[1] %in% c("Gene","gene","gene_id","X")) {
  rownames(counts) <- make.unique(as.character(counts[[1]]))
  counts[[1]] <- NULL
}

counts <- as.matrix(counts)
storage.mode(counts) <- "numeric"
counts <- round(counts)
stopifnot(all(counts >= 0), all(abs(counts - round(counts)) < 1e-6, na.rm = TRUE))

# -------------------------
# 2) Keep only sgRNAneg_ATc and sgRNApos_ATc (all BRs)
# -------------------------
samples <- colnames(counts)
samps_l <- tolower(samples)

keep <- grepl("sgrnaneg_atc$", samps_l) | grepl("sgrnapos_atc$", samps_l)
# If your names don't end with that, use looser patterns:
# keep <- grepl("sgrnaneg.*atc", samps_l) | grepl("sgrnapos.*atc", samps_l)

counts <- counts[, keep, drop = FALSE]
stopifnot(ncol(counts) == 6)  # expecting 6 samples

samples <- colnames(counts)
samps_l <- tolower(samples)

# replicate parsing: BR1/BR2/BR3
replicate <- factor(toupper(sub("^((br)[0-9]+).*", "\\1", samps_l)),
                    levels = c("BR1","BR2","BR3"))

# two-level condition from names
condition2 <- ifelse(grepl("sgrnaneg_atc", samps_l), "sgRNAneg_ATc", "sgRNApos_ATc")
condition2 <- factor(condition2, levels = c("sgRNAneg_ATc", "sgRNApos_ATc"))

coldata <- data.frame(
  sample     = samples,
  condition2 = condition2,
  replicate  = replicate,
  row.names  = samples
)

print(table(coldata$condition2, coldata$replicate))


# 3) DESeq2 with rlog data

dds <- DESeqDataSetFromMatrix(
  countData = counts,
  colData   = coldata,
  design    = ~ replicate + condition2
)

# optional but common: drop all-zero genes (avoids issues)
dds <- dds[rowSums(counts(dds)) > 0, ]

# rlog can be slow; for >~30 samples I'd recommend vst. Here n=6 so rlog is fine.
rld <- rlog(dds, blind = FALSE)
E_rlog <- assay(rld)

# 4) PCA helper (AI-generated tool)
plot_pc12 <- function(expr_mat, meta, title) {
  row_vars <- apply(expr_mat, 1, var, na.rm = TRUE)
  expr_mat <- expr_mat[is.finite(row_vars) & row_vars > 0, , drop = FALSE]

  pca <- prcomp(t(expr_mat), center = TRUE, scale. = FALSE)
  pv <- (pca$sdev^2) / sum(pca$sdev^2) * 100

  df <- data.frame(
    PC1 = pca$x[,1],
    PC2 = pca$x[,2],
    sample     = rownames(pca$x),
    condition2 = meta[rownames(pca$x), "condition2"],
    replicate  = meta[rownames(pca$x), "replicate"],
    check.names = FALSE
  )

  ggplot(df, aes(PC1, PC2, color = condition2, shape = replicate, label = sample)) +
    geom_point(size = 3) +
    geom_text_repel(size = 3, show.legend = FALSE, max.overlaps = Inf) +
    theme_classic(base_size = 12) +
    labs(
      title = title,
      x = sprintf("PC1 (%.1f%%)", pv[1]),
      y = sprintf("PC2 (%.1f%%)", pv[2]),
      color = "condition",
      shape = "replicate"
    )
}

# 5) PCA on rlog only

p_raw <- plot_pc12(E_rlog, coldata, "PCA (DESeq2 rlog): PC1 vs PC2")

# 6) PCA on rlog + removing batch effect (visualisation only)
E_rm <- removeBatchEffect(
  E_rlog,
  batch  = coldata$replicate,
  design = model.matrix(~ condition2, data = coldata)
)

p_rm <- plot_pc12(E_rm, coldata, "PCA (rlog, donor removed): PC1 vs PC2")

print(p_raw)
print(p_rm)

# Save plots

ggsave(file.path(outdir, "PCA_rlog_PC1_PC2.png"), plot = p_raw, width = 7, height = 5, dpi = 300)
ggsave(file.path(outdir, "PCA_rlog_batchRemoved_PC1_PC2.png"), plot = p_rm, width = 7, height = 5, dpi = 300)

```

## DESeq2

Now you have deciphered from the PCA whether or not batch plays a role, you can add replicate as a factor in the DESeq2 model through \~ replicate + condition and run the model on the original counts matrix (n my case, CountsMatrix1)"

```{r}

## Run DESeq2 (unshrunk + shrunk LFC)

# Significance (pvalue/padj) comes from `results()`.
# Shrinkage (`lfcShrink(..., type="apeglm")`) stabilises log2FC for ranking/reporting, but typically does not change padj, and is useful for downstream analysis (though once I looked at the data from both shrinking actually doesnt alter fold change much)

# rebuild coldata from count_mat_atc to guarantee matching
samples <- colnames(count_mat_atc)
samps_l <- tolower(samples)

replicate <- factor(sub("^(br[123]).*", "\\1", samps_l), levels = c("br1","br2","br3"))
condition <- ifelse(grepl("sgrnaneg_atc$", samps_l), "sgRNAneg_ATc", "sgRNApos_ATc")
condition <- factor(condition, levels = c("sgRNAneg_ATc", "sgRNApos_ATc"))

coldata <- data.frame(
  replicate = replicate,
  condition = condition,
  row.names = samples
)

# sanity
stopifnot(all(rownames(coldata) == colnames(count_mat_atc)))
colnames(coldata)


dds_full <- DESeqDataSetFromMatrix(
  countData = count_mat_atc,
  colData   = coldata,
  design    = ~ replicate + condition
)

dds_full <- DESeq(dds_full)

# Unshrunk results
res <- results(dds_full, contrast = c("condition", "sgRNApos_ATc", "sgRNAneg_ATc"))

# Shrunk log2FC (apeglm)
LFC <- lfcShrink(
  dds_full,
  coef = "condition_sgRNApos_ATc_vs_sgRNAneg_ATc",
  res  = res,
  type = "apeglm"
)
summary(res)
```

To look at significant genes (i.e., padj \< 0.05):

```{sum(!is.na(res$padj) & res$padj < 0.05)}
sum(!is.na(LFC$padj) & LFC$padj < 0.05)
```

To export res (DESeq2 table):

```{r}

# Export results tables; export both unshrunk and shrunk.

prefix <- "sgRNApos_ATc_vs_sgRNAneg_ATc"

# Unshrunk
res_df <- as.data.frame(res)
res_df$MSMEG <- rownames(res_df)
res_df <- res_df[, c("MSMEG", setdiff(colnames(res_df), "MSMEG"))]
write.csv(res_df, file.path(out_tables, paste0(prefix, "_DESeq2_unshrunk.csv")), row.names = FALSE)

# Shrunk
lfc_df <- as.data.frame(LFC)
lfc_df$MSMEG <- rownames(lfc_df)
lfc_df <- lfc_df[, c("MSMEG", setdiff(colnames(lfc_df), "MSMEG"))]
write.csv(lfc_df, file.path(out_tables, paste0(prefix, "_DESeq2_apeglm_shrunk.csv")), row.names = FALSE)

# Significant table (FDR < 0.05)
sig_df <- lfc_df[!is.na(lfc_df$padj) & lfc_df$padj < 0.05, ]
sig_df <- sig_df[order(sig_df$padj), ]
write.csv(sig_df, file.path(out_tables, paste0(prefix, "_FDRsig_all.csv")), row.names = FALSE)

nrow(sig_df)

# Convert to data frame
res_df <- data.frame(
+     gene_id = rownames(res),
+     as.data.frame(res),
+     row.names = NULL
)

# Keep standard DESeq2 columns
res_df <- res_df[, c(
+     "gene_id",
+     "baseMean",
+     "log2FoldChange",
+     "lfcSE",
+     "stat",
+     "pvalue",
+     "padj"
)]

# Write CSV to correct folder
write.csv(
+     res_df,
+     file = file.path(outdir, "DESeq2_BR3_sgRNAposATc_vs_sgRNAnegATc.csv"),
+     row.names = FALSE
)
sink(file.path(outdir, "DESeq2_BR3_summary.txt"))
summary(res)
```

```{r}

sig_genes <- rownames(res)[!is.na(res$padj) & res$padj < 0.05]
length(sig_genes)

plot_one_gene <- function(gene_id) {
  tmp <- plotCounts(dds_full,
                    gene = gene_id,
                    intgroup = "condition",
                    returnData = TRUE)

  ggplot(tmp, aes(x = condition, y = count)) +
    geom_boxplot(outlier.shape = NA) +
    geom_dotplot(binaxis = "y", stackdir = "center", dotsize = 0.6) +
    theme_classic(base_size = 12) +
    labs(title = paste0(gene_id, " expression"),
         x = "condition", y = "normalized count")
}

pdf(file.path(out_plots, paste0(prefix, "_plotCounts_FDRsig_all.pdf")),
    width = 6, height = 4.5)
for (g in sig_genes) print(plot_one_gene(g))
dev.off()
